import { Operation, RequestBody } from "@pastapi/core";
import {
  toZod,
  expressPath,
  fuc,
  includes,
  concatIfNotEmpty,
} from "../helpers";

const supportedContentTypes = [
  "application/json",
  "application/x-www-form-urlencoded",
];

export const generate = (ops: Operation[]): string => `
${buildHeader()}

import { Request, Response, Router } from "express";
import { z } from "zod";
${operationNamespaces(ops)}
${handlerType(ops)}
${router(ops)}
${zodStringPreprocessor()}
`;

const buildHeader = () => `
/*  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
/   â•‘ ðŸ  Generated by Pastapi  ðŸ â•‘
/   â•‘        Do not modify.        â•‘
/   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/   
/   Dependencies:
/   - body-parser to validate bodies
*/`;

const operationNamespaces = (ast: Operation[]) => `
${ast.map(operationNamespace).join("\n")}`;

const operationNamespace = (o: Operation) => {
  const requestBodies = o.requestBodies.filter((rb) =>
    includes(supportedContentTypes, rb.applicationType)
  );
  return `
export namespace ${fuc(o.operationId)} {
  export const bodySchemas = {
    ${requestBodies.map(
      (rb) => `"${rb.applicationType}" : ${toZod(rb.bodySchema)}`
    )}
  }
  export type ParsedBody = {
    ${requestBodies.map(
      (rb) =>
        `"${rb.applicationType}" : z.infer<typeof bodySchemas["${rb.applicationType}"]> | undefined`
    )}
  }
  export type ParsedContentType = keyof ParsedBody
  export const parameterSchemas = {
    ${o.requestParameters.map((p) => `"${p.name}" : ${toZod(p.schema)}`)}
  }
  export type ParsedParameters = {
    ${o.requestParameters.map(
      (p) =>
        `"${p.name}" : z.infer<typeof parameterSchemas["${p.name}"]> | undefined`
    )}
  }
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined,
    body: ParsedBody
    parameters: ParsedParameters
  }
  export type Handler = (req: Request, res: Response, parsed: Parsed) => Promise<void>

  ${parseFunction(o, requestBodies)}
  ${createRouter(o)}
}`;
};

const parseFunction = (o: Operation, requestBodies: RequestBody[]) => `
export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        ${o.requestBodies
          .filter((rb) => includes(supportedContentTypes, rb.applicationType))
          .map((rb) => `"${rb.applicationType}" : undefined`)
          .join(",\n")}
      },
      parameters: {
        ${o.requestParameters.map((p) => `"${p.name}" : undefined`).join(",\n")}
      }
    }
    
    ${
      requestBodies.length > 0
        ? `
        // parse body
        const contentType = req.headers["content-type"];
        if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
          const parsedContentType = contentType as ParsedContentType
          parsed.bodyContentType = parsedContentType;
          parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(req.body.data);
        }
    `
        : ""
    }

    ${o.requestParameters
      .filter((p) => p.in == "path")
      .map(
        (p) => `// parse ${p.name}
        const ${p.name}Param = req.params["${p.name}"];
        const ${p.name}ParamCasted = tryCastStringForZod(parameterSchemas["${p.name}"], ${p.name}Param);
        parsed.parameters["${p.name}"] = parameterSchemas["${p.name}"]?.parse(${p.name}ParamCasted);`
      )
      .join("\n")}
    
      return parsed;
  }`;

const createRouter = (o: Operation) => `
export const createRouter = (handler: Handler | undefined, logging?: boolean | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(\`\${req.method} \${req.path}\`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      ${concatIfNotEmpty(
        o.responses.map(
          (r) => `if (${
            r.statusCode !== "default"
              ? `res.statusCode == ${r.statusCode} &&`
              : ``
          } res.getHeader("content-type") === "${r.applicationType}") {
                // TODO validate ${r.applicationType} ${r.statusCode} response
              }`
        ),
        `{
          // response not handled
        }`
      ).join(" else ")}

      next();
    });
    return router;
}
`;

const handlerType = (ast: Operation[]) => `
export type PastapiHandlers = {
${ast.map(handlerTypeHandler).join("\n")}
}`;

const handlerTypeHandler = (o: Operation) =>
  `  ${o.operationId}?: ${fuc(o.operationId)}.Handler | undefined`;

const router = (ast: Operation[]) => `
export function createRouter(handlers: PastapiHandlers, logging?: boolean | undefined): Router {
  const router = Router();
  ${ast.map(route).join("\n")}
  return router;
}`;

const route = (o: Operation) => `
    router.${o.method}("${expressPath(o.path)}", ${fuc(
      o.operationId
    )}.createRouter(handlers.${o.operationId}, logging));
  `;
const zodStringPreprocessor = () => `
export function castStringForZod(
  schema: z.ZodTypeAny,
  value: string
): any | undefined {
  if (schema instanceof z.ZodNumber) {
    if (schema._def.checks.map((c) => c.kind).includes("int")) {
      const casted = parseInt(value);
      return !isNaN(casted) ? casted : undefined;
    } else {
      const casted = parseFloat(value);
      return !isNaN(casted) ? casted : undefined;
    }
  } else if ((schema as any) instanceof z.ZodBoolean) {
    if (value === "true") {
      return true;
    } else if (value === "false") {
      return false;
    } else {
      return undefined;
    }
  }
}

export function tryCastStringForZod(schema: z.ZodTypeAny, value: string): any {
  return castStringForZod(schema, value) ?? value;
}

`;
