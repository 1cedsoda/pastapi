import { Operation, RequestBody, RequestParameter } from "@pastapi/core";
import { toZod, expressPath, fuc, camelCase } from "../helpers";
import { z } from "zod";

export const generate = (ops: Operation[]): string => `
${buildHeader()}

import { Request, Response, Router } from "express";
import { z } from "zod";
${operationNamespaces(ops)}
${handlerType(ops)}
${router(ops)}
${zodPreprocessors()}
${singleFunction()}
${keysIncludeFunction()}
`;

const buildHeader = () => `
/*  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
/   â•‘ ðŸ  Generated by Pastapi  ðŸ â•‘
/   â•‘        Do not modify.        â•‘
/   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/   
/   External Middleware Dependencies:
/   - body-parser to validate bodies
/   - cookie-parser to validate cookies
*/`;

const operationNamespaces = (ast: Operation[]) => `
${ast.map(operationNamespace).join("\n")}`;

const operationNamespace = (o: Operation) => {
  return `
export namespace ${fuc(o.operationId)} {
  export const bodySchemas = {
    ${o.requestBodies.map(
      (rb) => `"${rb.applicationType}" : ${toZod(rb.bodySchema)}`
    )}
  }
  export type ParsedBody = {
    ${o.requestBodies.map(
      (rb) =>
        `"${rb.applicationType}" : z.infer<typeof bodySchemas["${rb.applicationType}"]> | undefined`
    )}
  }
  export type ParsedContentType = keyof ParsedBody
  export const parameterSchemas = {
    ${o.requestParameters.map(
      (p) =>
        `${camelCase(p.name)} : ${toZod(p.schema)}${
          p.required ? "" : ".optional()"
        }`
    )}
  }
  export type ParsedParameters = {
    ${o.requestParameters.map(
      (p) =>
        `${camelCase(p.name)} : z.infer<typeof parameterSchemas["${camelCase(
          p.name
        )}"]>`
    )}
  }
  export type Parsed = {
    contentType: ParsedContentType | undefined,
    body: ParsedBody
    parameters: ParsedParameters
  }
  export type Handler = (req: Request, res: Response, parsed: Parsed) => Promise<void>

  ${parseFunction(o)}
  ${createRouter(o)}
}`;
};

const parseFunction = (o: Operation) => `
export const parse = (req: Request): Parsed => {
    ${
      o.requestBodies.length > 0
        ? `// parse body
            const _contentType = single(req.headers["Content-Type"]);
            const contentType = 
            _contentType !== undefined &&
            keysInclude(bodySchemas, _contentType)
              ? _contentType as ParsedContentType
              : undefined;`
        : `const contentType = undefined`
    }

  const parsed: Parsed = {
    contentType,
    body: {
      ${o.requestBodies
        .map(
          (rb) =>
            `"${rb.applicationType}" : contentType === "${rb.applicationType}" ? bodySchemas["${rb.applicationType}"]?.parse(req.body.data, { path: ["body"] }) : undefined`
        )
        .join(",\n")}
    },
    parameters: {
      ${o.requestParameters
        .map(
          (p) => `
      "${camelCase(p.name)}": parameterSchemas.${camelCase(
        p.name
      )}?.parse(${readParameter(p)}, { path: ["${p.in}", "${p.name}"] })
      `
        )
        .join(",\n")}
    }
  };

  return parsed;
  }`;

const readParameter = (p: RequestParameter) => {
  if (p.in === "path") {
    return `castStringForZod(parameterSchemas.${camelCase(
      p.name
    )}, req.params["${p.name}"])`;
  }
  if (p.in === "query") {
    return `castParsedQueryStringForZod(parameterSchemas.${camelCase(
      p.name
    )}, req.query["${p.name}"])`;
  }
  if (p.in === "header") {
    return `castStringForZod(parameterSchemas.${camelCase(
      p.name
    )}, single(req.headers["${p.name}"]))`;
  }
  if (p.in === "cookie") {
    return `castStringForZod(parameterSchemas.${camelCase(
      p.name
    )}, req.cookies["${p.name}"])`;
  }
};

const createRouter = (o: Operation) => `
export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) {
          res.status(422).send(e.issues);
        } else {
          res.status(500).send(e);
        }
        return next();
      }
      if (handler !== undefined) {
        handler(req, res, parsed);
      } else {
        res.status(501).send("Not Implemented");
      }
      next();
    });
    return router;
}
`;

const handlerType = (ast: Operation[]) => `
export type PastapiHandlers = {
${ast.map(handlerTypeHandler).join("\n")}
}`;

const handlerTypeHandler = (o: Operation) =>
  `  ${o.operationId}?: ${fuc(o.operationId)}.Handler | undefined`;

const router = (ast: Operation[]) => `
export function createRouter(handlers: PastapiHandlers): Router {
  const router = Router();
  ${ast.map(route).join("\n")}
  return router;
}`;

const route = (o: Operation) => `
    router.${o.method}("${expressPath(o.path)}", ${fuc(
      o.operationId
    )}.createRouter(handlers.${o.operationId}));
  `;
const zodPreprocessors = () => `
export function tryCastStringForZod(
  schema: z.ZodTypeAny,
  value: string | undefined
): any | undefined {
  if (value === undefined) {
    return undefined;
  }
  if (schema instanceof z.ZodNumber) {
    if (schema._def.checks.map((c) => c.kind).includes("int")) {
      const casted = parseInt(value);
      return !isNaN(casted) ? casted : undefined;
    } else {
      const casted = parseFloat(value);
      return !isNaN(casted) ? casted : undefined;
    }
  } else if ((schema as any) instanceof z.ZodBoolean) {
    if (value === "true") {
      return true;
    } else if (value === "false") {
      return false;
    } else {
      return undefined;
    }
  }
}

export function castStringForZod(schema: z.ZodTypeAny, value: string | undefined): any {
  return tryCastStringForZod(schema, value) ?? value;
}

export function castParsedQueryStringForZod(schema: z.ZodTypeAny, value: any): any {
  if (typeof value === "string") {
    return castStringForZod(schema, value);
  }
  return value as any;
}
`;

const singleFunction = () => `
export function single<T>(input: T | T[]): T {
  return Array.isArray(input) ? input[0] : input;
}
`;

const keysIncludeFunction = () => `
export function keysInclude<T extends object>(obj: T, key: keyof any): key is keyof T {
  return Object.keys(obj).indexOf(key as string) !== -1;
}
`;
