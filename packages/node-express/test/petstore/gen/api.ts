/*  ╔══════════════════════════════╗
/   ║ 🍝  Generated by Pastapi  🍝 ║
/   ║        Do not modify.        ║
/   ╚══════════════════════════════╝
/   
/   External Middleware Dependencies:
/   - body-parser to validate bodies
/   - cookie-parser to validate cookies
*/
import { Request, Response, Router } from "express";
import { z } from "zod";

export namespace UpdatePet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/xml":
      | z.infer<(typeof bodySchemas)["application/xml"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/xml":
          contentType === "application/xml"
            ? bodySchemas["application/xml"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/x-www-form-urlencoded":
          contentType === "application/x-www-form-urlencoded"
            ? bodySchemas["application/x-www-form-urlencoded"]?.parse(
                req.body.data,
                { path: ["body"] },
              )
            : undefined,
      },
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace AddPet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/xml":
      | z.infer<(typeof bodySchemas)["application/xml"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/xml":
          contentType === "application/xml"
            ? bodySchemas["application/xml"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/x-www-form-urlencoded":
          contentType === "application/x-www-form-urlencoded"
            ? bodySchemas["application/x-www-form-urlencoded"]?.parse(
                req.body.data,
                { path: ["body"] },
              )
            : undefined,
      },
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace FindPetsByStatus {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    status: z
      .enum(["available", "pending", "sold"])
      .default("available")
      .optional(),
  };
  export type ParsedParameters = {
    status: z.infer<(typeof parameterSchemas)["status"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        status: parameterSchemas.status?.parse(
          castParsedQueryStringForZod(
            parameterSchemas.status,
            req.query["status"],
          ),
          { path: ["query", "status"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace FindPetsByTags {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    tags: z.array(z.string()).optional(),
  };
  export type ParsedParameters = {
    tags: z.infer<(typeof parameterSchemas)["tags"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        tags: parameterSchemas.tags?.parse(
          castParsedQueryStringForZod(parameterSchemas.tags, req.query["tags"]),
          { path: ["query", "tags"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace GetPetById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        petId: parameterSchemas.petId?.parse(
          castStringForZod(parameterSchemas.petId, req.params["petId"]),
          { path: ["path", "petId"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace UpdatePetWithForm {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    name: z.string().optional(),
    status: z.string().optional(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]>;
    name: z.infer<(typeof parameterSchemas)["name"]>;
    status: z.infer<(typeof parameterSchemas)["status"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        petId: parameterSchemas.petId?.parse(
          castStringForZod(parameterSchemas.petId, req.params["petId"]),
          { path: ["path", "petId"] },
        ),
        name: parameterSchemas.name?.parse(
          castParsedQueryStringForZod(parameterSchemas.name, req.query["name"]),
          { path: ["query", "name"] },
        ),
        status: parameterSchemas.status?.parse(
          castParsedQueryStringForZod(
            parameterSchemas.status,
            req.query["status"],
          ),
          { path: ["query", "status"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace DeletePet {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    apiKey: z.string().optional(),
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    apiKey: z.infer<(typeof parameterSchemas)["apiKey"]>;
    petId: z.infer<(typeof parameterSchemas)["petId"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        apiKey: parameterSchemas.apiKey?.parse(
          castStringForZod(
            parameterSchemas.apiKey,
            single(req.headers["api_key"]),
          ),
          { path: ["header", "api_key"] },
        ),
        petId: parameterSchemas.petId?.parse(
          castStringForZod(parameterSchemas.petId, req.params["petId"]),
          { path: ["path", "petId"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace UploadFile {
  export const bodySchemas = {
    "application/octet-stream": z.string(),
  };
  export type ParsedBody = {
    "application/octet-stream":
      | z.infer<(typeof bodySchemas)["application/octet-stream"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    additionalMetadata: z.string().optional(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]>;
    additionalMetadata: z.infer<
      (typeof parameterSchemas)["additionalMetadata"]
    >;
  };
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/octet-stream":
          contentType === "application/octet-stream"
            ? bodySchemas["application/octet-stream"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
      },
      parameters: {
        petId: parameterSchemas.petId?.parse(
          castStringForZod(parameterSchemas.petId, req.params["petId"]),
          { path: ["path", "petId"] },
        ),
        additionalMetadata: parameterSchemas.additionalMetadata?.parse(
          castParsedQueryStringForZod(
            parameterSchemas.additionalMetadata,
            req.query["additionalMetadata"],
          ),
          { path: ["query", "additionalMetadata"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace GetInventory {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace PlaceOrder {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/xml":
      | z.infer<(typeof bodySchemas)["application/xml"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/xml":
          contentType === "application/xml"
            ? bodySchemas["application/xml"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/x-www-form-urlencoded":
          contentType === "application/x-www-form-urlencoded"
            ? bodySchemas["application/x-www-form-urlencoded"]?.parse(
                req.body.data,
                { path: ["body"] },
              )
            : undefined,
      },
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace GetOrderById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        orderId: parameterSchemas.orderId?.parse(
          castStringForZod(parameterSchemas.orderId, req.params["orderId"]),
          { path: ["path", "orderId"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace DeleteOrder {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        orderId: parameterSchemas.orderId?.parse(
          castStringForZod(parameterSchemas.orderId, req.params["orderId"]),
          { path: ["path", "orderId"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace CreateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/xml":
      | z.infer<(typeof bodySchemas)["application/xml"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/xml":
          contentType === "application/xml"
            ? bodySchemas["application/xml"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/x-www-form-urlencoded":
          contentType === "application/x-www-form-urlencoded"
            ? bodySchemas["application/x-www-form-urlencoded"]?.parse(
                req.body.data,
                { path: ["body"] },
              )
            : undefined,
      },
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace CreateUsersWithListInput {
  export const bodySchemas = {
    "application/json": z.array(
      z.object({
        id: z.number().int().optional(),
        username: z.string().optional(),
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        email: z.string().optional(),
        password: z.string().optional(),
        phone: z.string().optional(),
        userStatus: z.number().int().optional(),
      }),
    ),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
      },
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace LoginUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string().optional(),
    password: z.string().optional(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]>;
    password: z.infer<(typeof parameterSchemas)["password"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        username: parameterSchemas.username?.parse(
          castParsedQueryStringForZod(
            parameterSchemas.username,
            req.query["username"],
          ),
          { path: ["query", "username"] },
        ),
        password: parameterSchemas.password?.parse(
          castParsedQueryStringForZod(
            parameterSchemas.password,
            req.query["password"],
          ),
          { path: ["query", "password"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace LogoutUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace GetUserByName {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        username: parameterSchemas.username?.parse(
          castStringForZod(parameterSchemas.username, req.params["username"]),
          { path: ["path", "username"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace UpdateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/xml":
      | z.infer<(typeof bodySchemas)["application/xml"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]>;
  };
  export type Parsed = {
    contentType: ParsedContentType;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    z.string().parse(req.headers["Content-Type"], {
      path: ["header", "Content-Type"],
    });
    const contentType = single(
      req.headers["Content-Type"],
    ) as ParsedContentType;

    const parsed: Parsed = {
      contentType,
      body: {
        "application/json":
          contentType === "application/json"
            ? bodySchemas["application/json"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/xml":
          contentType === "application/xml"
            ? bodySchemas["application/xml"]?.parse(req.body.data, {
                path: ["body"],
              })
            : undefined,
        "application/x-www-form-urlencoded":
          contentType === "application/x-www-form-urlencoded"
            ? bodySchemas["application/x-www-form-urlencoded"]?.parse(
                req.body.data,
                { path: ["body"] },
              )
            : undefined,
      },
      parameters: {
        username: parameterSchemas.username?.parse(
          castStringForZod(parameterSchemas.username, req.params["username"]),
          { path: ["path", "username"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export namespace DeleteUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]>;
  };
  export type Parsed = {
    contentType: undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const contentType = undefined;

    const parsed: Parsed = {
      contentType,
      body: {},
      parameters: {
        username: parameterSchemas.username?.parse(
          castStringForZod(parameterSchemas.username, req.params["username"]),
          { path: ["path", "username"] },
        ),
      },
    };

    return parsed;
  };

  export const createRouter = (handler: Handler | undefined): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        if (e instanceof z.ZodError) res.status(422).send(e.issues);
        else res.status(500).send(e);
        return next();
      }
      if (handler !== undefined) handler(req, res, parsed);
      next();
    });
    return router;
  };
}

export type PastapiHandlers = {
  updatePet?: UpdatePet.Handler | undefined;
  addPet?: AddPet.Handler | undefined;
  findPetsByStatus?: FindPetsByStatus.Handler | undefined;
  findPetsByTags?: FindPetsByTags.Handler | undefined;
  getPetById?: GetPetById.Handler | undefined;
  updatePetWithForm?: UpdatePetWithForm.Handler | undefined;
  deletePet?: DeletePet.Handler | undefined;
  uploadFile?: UploadFile.Handler | undefined;
  getInventory?: GetInventory.Handler | undefined;
  placeOrder?: PlaceOrder.Handler | undefined;
  getOrderById?: GetOrderById.Handler | undefined;
  deleteOrder?: DeleteOrder.Handler | undefined;
  createUser?: CreateUser.Handler | undefined;
  createUsersWithListInput?: CreateUsersWithListInput.Handler | undefined;
  loginUser?: LoginUser.Handler | undefined;
  logoutUser?: LogoutUser.Handler | undefined;
  getUserByName?: GetUserByName.Handler | undefined;
  updateUser?: UpdateUser.Handler | undefined;
  deleteUser?: DeleteUser.Handler | undefined;
};

export function createRouter(handlers: PastapiHandlers): Router {
  const router = Router();

  router.put("/pet", UpdatePet.createRouter(handlers.updatePet));

  router.post("/pet", AddPet.createRouter(handlers.addPet));

  router.get(
    "/pet/findByStatus",
    FindPetsByStatus.createRouter(handlers.findPetsByStatus),
  );

  router.get(
    "/pet/findByTags",
    FindPetsByTags.createRouter(handlers.findPetsByTags),
  );

  router.get("/pet/:petId", GetPetById.createRouter(handlers.getPetById));

  router.post(
    "/pet/:petId",
    UpdatePetWithForm.createRouter(handlers.updatePetWithForm),
  );

  router.delete("/pet/:petId", DeletePet.createRouter(handlers.deletePet));

  router.post(
    "/pet/:petId/uploadImage",
    UploadFile.createRouter(handlers.uploadFile),
  );

  router.get(
    "/store/inventory",
    GetInventory.createRouter(handlers.getInventory),
  );

  router.post("/store/order", PlaceOrder.createRouter(handlers.placeOrder));

  router.get(
    "/store/order/:orderId",
    GetOrderById.createRouter(handlers.getOrderById),
  );

  router.delete(
    "/store/order/:orderId",
    DeleteOrder.createRouter(handlers.deleteOrder),
  );

  router.post("/user", CreateUser.createRouter(handlers.createUser));

  router.post(
    "/user/createWithList",
    CreateUsersWithListInput.createRouter(handlers.createUsersWithListInput),
  );

  router.get("/user/login", LoginUser.createRouter(handlers.loginUser));

  router.get("/user/logout", LogoutUser.createRouter(handlers.logoutUser));

  router.get(
    "/user/:username",
    GetUserByName.createRouter(handlers.getUserByName),
  );

  router.put("/user/:username", UpdateUser.createRouter(handlers.updateUser));

  router.delete(
    "/user/:username",
    DeleteUser.createRouter(handlers.deleteUser),
  );

  return router;
}

export function tryCastStringForZod(
  schema: z.ZodTypeAny,
  value: string | undefined,
): any | undefined {
  if (value === undefined) {
    return undefined;
  }
  if (schema instanceof z.ZodNumber) {
    if (schema._def.checks.map((c) => c.kind).includes("int")) {
      const casted = parseInt(value);
      return !isNaN(casted) ? casted : undefined;
    } else {
      const casted = parseFloat(value);
      return !isNaN(casted) ? casted : undefined;
    }
  } else if ((schema as any) instanceof z.ZodBoolean) {
    if (value === "true") {
      return true;
    } else if (value === "false") {
      return false;
    } else {
      return undefined;
    }
  }
}

export function castStringForZod(
  schema: z.ZodTypeAny,
  value: string | undefined,
): any {
  return tryCastStringForZod(schema, value) ?? value;
}

export function castParsedQueryStringForZod(
  schema: z.ZodTypeAny,
  value: any,
): any {
  if (typeof value === "string") {
    return castStringForZod(schema, value);
  }
  return value as any;
}

export function single<T>(input: T | T[]): T {
  return Array.isArray(input) ? input[0] : input;
}

export function keysInclude<T extends object>(
  obj: T,
  key: keyof any,
): key is keyof T {
  return Object.keys(obj).indexOf(key as string) !== -1;
}
