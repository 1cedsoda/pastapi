/*  ╔══════════════════════════════╗
/   ║ 🍝  Generated by Pastapi  🍝 ║
/   ║        Do not modify.        ║
/   ╚══════════════════════════════╝
/   
/   Dependencies:
/   - body-parser to validate bodies
*/

import { Request, Response, Router } from "express";
import { z } from "zod";

export namespace UpdatePet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace AddPet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace FindPetsByStatus {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    status: z.enum(["available", "pending", "sold"]).default("available"),
  };
  export type ParsedParameters = {
    status: z.infer<(typeof parameterSchemas)["status"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        status: undefined,
      },
    };

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace FindPetsByTags {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    tags: z.array(z.string()),
  };
  export type ParsedParameters = {
    tags: z.infer<(typeof parameterSchemas)["tags"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        tags: undefined,
      },
    };

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace GetPetById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    const petIdParamCasted = tryCastStringForZod(
      parameterSchemas["petId"],
      petIdParam,
    );
    parsed.parameters["petId"] =
      parameterSchemas["petId"]?.parse(petIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace UpdatePetWithForm {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    name: z.string(),
    status: z.string(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
    name: z.infer<(typeof parameterSchemas)["name"]> | undefined;
    status: z.infer<(typeof parameterSchemas)["status"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
        name: undefined,
        status: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    const petIdParamCasted = tryCastStringForZod(
      parameterSchemas["petId"],
      petIdParam,
    );
    parsed.parameters["petId"] =
      parameterSchemas["petId"]?.parse(petIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export namespace DeletePet {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    api_key: z.string(),
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    api_key: z.infer<(typeof parameterSchemas)["api_key"]> | undefined;
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        api_key: undefined,
        petId: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    const petIdParamCasted = tryCastStringForZod(
      parameterSchemas["petId"],
      petIdParam,
    );
    parsed.parameters["petId"] =
      parameterSchemas["petId"]?.parse(petIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export namespace UploadFile {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    additionalMetadata: z.string(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
    additionalMetadata:
      | z.infer<(typeof parameterSchemas)["additionalMetadata"]>
      | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
        additionalMetadata: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    const petIdParamCasted = tryCastStringForZod(
      parameterSchemas["petId"],
      petIdParam,
    );
    parsed.parameters["petId"] =
      parameterSchemas["petId"]?.parse(petIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace GetInventory {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace PlaceOrder {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace GetOrderById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        orderId: undefined,
      },
    };

    // parse orderId
    const orderIdParam = req.params["orderId"];
    const orderIdParamCasted = tryCastStringForZod(
      parameterSchemas["orderId"],
      orderIdParam,
    );
    parsed.parameters["orderId"] =
      parameterSchemas["orderId"]?.parse(orderIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace DeleteOrder {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        orderId: undefined,
      },
    };

    // parse orderId
    const orderIdParam = req.params["orderId"];
    const orderIdParamCasted = tryCastStringForZod(
      parameterSchemas["orderId"],
      orderIdParam,
    );
    parsed.parameters["orderId"] =
      parameterSchemas["orderId"]?.parse(orderIdParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export namespace CreateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (res.getHeader("Content-Type") === "application/json") {
        // TODO validate application/json default response
      } else if (res.getHeader("Content-Type") === "application/xml") {
        // TODO validate application/xml default response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace CreateUsersWithListInput {
  export const bodySchemas = {
    "application/json": z.array(
      z.object({
        id: z.number().int().optional(),
        username: z.string().optional(),
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        email: z.string().optional(),
        password: z.string().optional(),
        phone: z.string().optional(),
        userStatus: z.number().int().optional(),
      }),
    ),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace LoginUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
    password: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
    password: z.infer<(typeof parameterSchemas)["password"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
        password: undefined,
      },
    };

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace LogoutUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {},
    };

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export namespace GetUserByName {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
      },
    };

    // parse username
    const usernameParam = req.params["username"];
    const usernameParamCasted = tryCastStringForZod(
      parameterSchemas["username"],
      usernameParam,
    );
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/json"
      ) {
        // TODO validate application/json 200 response
      } else if (
        res.statusCode == 200 &&
        res.getHeader("Content-Type") === "application/xml"
      ) {
        // TODO validate application/xml 200 response
      } else {
        // response not handled
      }

      next();
    });
    return router;
  };
}

export namespace UpdateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {
        username: undefined,
      },
    };

    // parse body
    const contentType = single(req.headers["Content-Type"]);
    if (contentType && Object.keys(parsed.body).indexOf(contentType) !== -1) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body.data,
      );
    }

    // parse username
    const usernameParam = req.params["username"];
    const usernameParamCasted = tryCastStringForZod(
      parameterSchemas["username"],
      usernameParam,
    );
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export namespace DeleteUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
      },
    };

    // parse username
    const usernameParam = req.params["username"];
    const usernameParamCasted = tryCastStringForZod(
      parameterSchemas["username"],
      usernameParam,
    );
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParamCasted);

    return parsed;
  };

  export const createRouter = (
    handler: Handler | undefined,
    logging?: boolean | undefined,
  ): Router => {
    const router = Router({ mergeParams: true });
    router.use(async (req, res, next) => {
      if (logging) {
        console.log(`${req.method} ${req.path}`);
      }
      let parsed: Parsed;
      try {
        parsed = parse(req);
      } catch (e) {
        res.status(500).send(e);
        return next();
      }
      handler?.call({}, req, res, parsed);
      next();
    });
    router.use(async (req, res, next) => {
      next();
    });
    return router;
  };
}

export type PastapiHandlers = {
  updatePet?: UpdatePet.Handler | undefined;
  addPet?: AddPet.Handler | undefined;
  findPetsByStatus?: FindPetsByStatus.Handler | undefined;
  findPetsByTags?: FindPetsByTags.Handler | undefined;
  getPetById?: GetPetById.Handler | undefined;
  updatePetWithForm?: UpdatePetWithForm.Handler | undefined;
  deletePet?: DeletePet.Handler | undefined;
  uploadFile?: UploadFile.Handler | undefined;
  getInventory?: GetInventory.Handler | undefined;
  placeOrder?: PlaceOrder.Handler | undefined;
  getOrderById?: GetOrderById.Handler | undefined;
  deleteOrder?: DeleteOrder.Handler | undefined;
  createUser?: CreateUser.Handler | undefined;
  createUsersWithListInput?: CreateUsersWithListInput.Handler | undefined;
  loginUser?: LoginUser.Handler | undefined;
  logoutUser?: LogoutUser.Handler | undefined;
  getUserByName?: GetUserByName.Handler | undefined;
  updateUser?: UpdateUser.Handler | undefined;
  deleteUser?: DeleteUser.Handler | undefined;
};

export function createRouter(
  handlers: PastapiHandlers,
  logging?: boolean | undefined,
): Router {
  const router = Router();

  router.put("/pet", UpdatePet.createRouter(handlers.updatePet, logging));

  router.post("/pet", AddPet.createRouter(handlers.addPet, logging));

  router.get(
    "/pet/findByStatus",
    FindPetsByStatus.createRouter(handlers.findPetsByStatus, logging),
  );

  router.get(
    "/pet/findByTags",
    FindPetsByTags.createRouter(handlers.findPetsByTags, logging),
  );

  router.get(
    "/pet/:petId",
    GetPetById.createRouter(handlers.getPetById, logging),
  );

  router.post(
    "/pet/:petId",
    UpdatePetWithForm.createRouter(handlers.updatePetWithForm, logging),
  );

  router.delete(
    "/pet/:petId",
    DeletePet.createRouter(handlers.deletePet, logging),
  );

  router.post(
    "/pet/:petId/uploadImage",
    UploadFile.createRouter(handlers.uploadFile, logging),
  );

  router.get(
    "/store/inventory",
    GetInventory.createRouter(handlers.getInventory, logging),
  );

  router.post(
    "/store/order",
    PlaceOrder.createRouter(handlers.placeOrder, logging),
  );

  router.get(
    "/store/order/:orderId",
    GetOrderById.createRouter(handlers.getOrderById, logging),
  );

  router.delete(
    "/store/order/:orderId",
    DeleteOrder.createRouter(handlers.deleteOrder, logging),
  );

  router.post("/user", CreateUser.createRouter(handlers.createUser, logging));

  router.post(
    "/user/createWithList",
    CreateUsersWithListInput.createRouter(
      handlers.createUsersWithListInput,
      logging,
    ),
  );

  router.get(
    "/user/login",
    LoginUser.createRouter(handlers.loginUser, logging),
  );

  router.get(
    "/user/logout",
    LogoutUser.createRouter(handlers.logoutUser, logging),
  );

  router.get(
    "/user/:username",
    GetUserByName.createRouter(handlers.getUserByName, logging),
  );

  router.put(
    "/user/:username",
    UpdateUser.createRouter(handlers.updateUser, logging),
  );

  router.delete(
    "/user/:username",
    DeleteUser.createRouter(handlers.deleteUser, logging),
  );

  return router;
}

export function castStringForZod(
  schema: z.ZodTypeAny,
  value: string,
): any | undefined {
  if (schema instanceof z.ZodNumber) {
    if (schema._def.checks.map((c) => c.kind).includes("int")) {
      const casted = parseInt(value);
      return !isNaN(casted) ? casted : undefined;
    } else {
      const casted = parseFloat(value);
      return !isNaN(casted) ? casted : undefined;
    }
  } else if ((schema as any) instanceof z.ZodBoolean) {
    if (value === "true") {
      return true;
    } else if (value === "false") {
      return false;
    } else {
      return undefined;
    }
  }
}

export function tryCastStringForZod(schema: z.ZodTypeAny, value: string): any {
  return castStringForZod(schema, value) ?? value;
}

export function single<T>(input: T | T[]): T {
  return Array.isArray(input) ? input[0] : input;
}
