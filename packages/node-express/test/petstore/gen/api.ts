/*  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
/   ‚ïë üçù  Generated by Pastapi  üçù ‚ïë
/   ‚ïë        Do not modify.        ‚ïë
/   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
*/

import { Request, Response, Router } from "express";
import { z } from "zod";

export namespace UpdatePet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    return parsed;
  };
}

export namespace AddPet {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    return parsed;
  };
}

export namespace FindPetsByStatus {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    status: z.enum(["available", "pending", "sold"]).default("available"),
  };
  export type ParsedParameters = {
    status: z.infer<(typeof parameterSchemas)["status"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        status: undefined,
      },
    };

    return parsed;
  };
}

export namespace FindPetsByTags {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    tags: z.array(z.string()),
  };
  export type ParsedParameters = {
    tags: z.infer<(typeof parameterSchemas)["tags"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        tags: undefined,
      },
    };

    return parsed;
  };
}

export namespace GetPetById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    if (petIdParam === undefined) throw new Error("missing petId");
    parsed.parameters["petId"] = parameterSchemas["petId"]?.parse(petIdParam);

    return parsed;
  };
}

export namespace UpdatePetWithForm {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    name: z.string(),
    status: z.string(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
    name: z.infer<(typeof parameterSchemas)["name"]> | undefined;
    status: z.infer<(typeof parameterSchemas)["status"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
        name: undefined,
        status: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    if (petIdParam === undefined) throw new Error("missing petId");
    parsed.parameters["petId"] = parameterSchemas["petId"]?.parse(petIdParam);

    return parsed;
  };
}

export namespace DeletePet {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    api_key: z.string(),
    petId: z.number().int(),
  };
  export type ParsedParameters = {
    api_key: z.infer<(typeof parameterSchemas)["api_key"]> | undefined;
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        api_key: undefined,
        petId: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    if (petIdParam === undefined) throw new Error("missing petId");
    parsed.parameters["petId"] = parameterSchemas["petId"]?.parse(petIdParam);

    return parsed;
  };
}

export namespace UploadFile {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    petId: z.number().int(),
    additionalMetadata: z.string(),
  };
  export type ParsedParameters = {
    petId: z.infer<(typeof parameterSchemas)["petId"]> | undefined;
    additionalMetadata:
      | z.infer<(typeof parameterSchemas)["additionalMetadata"]>
      | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        petId: undefined,
        additionalMetadata: undefined,
      },
    };

    // parse petId
    const petIdParam = req.params["petId"];
    if (petIdParam === undefined) throw new Error("missing petId");
    parsed.parameters["petId"] = parameterSchemas["petId"]?.parse(petIdParam);

    return parsed;
  };
}

export namespace GetInventory {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {},
    };

    return parsed;
  };
}

export namespace PlaceOrder {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    return parsed;
  };
}

export namespace GetOrderById {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        orderId: undefined,
      },
    };

    // parse orderId
    const orderIdParam = req.params["orderId"];
    if (orderIdParam === undefined) throw new Error("missing orderId");
    parsed.parameters["orderId"] =
      parameterSchemas["orderId"]?.parse(orderIdParam);

    return parsed;
  };
}

export namespace DeleteOrder {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    orderId: z.number().int(),
  };
  export type ParsedParameters = {
    orderId: z.infer<(typeof parameterSchemas)["orderId"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        orderId: undefined,
      },
    };

    // parse orderId
    const orderIdParam = req.params["orderId"];
    if (orderIdParam === undefined) throw new Error("missing orderId");
    parsed.parameters["orderId"] =
      parameterSchemas["orderId"]?.parse(orderIdParam);

    return parsed;
  };
}

export namespace CreateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    return parsed;
  };
}

export namespace CreateUsersWithListInput {
  export const bodySchemas = {
    "application/json": z.array(
      z.object({
        id: z.number().int().optional(),
        username: z.string().optional(),
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        email: z.string().optional(),
        password: z.string().optional(),
        phone: z.string().optional(),
        userStatus: z.number().int().optional(),
      }),
    ),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
      },
      parameters: {},
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    return parsed;
  };
}

export namespace LoginUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
    password: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
    password: z.infer<(typeof parameterSchemas)["password"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
        password: undefined,
      },
    };

    return parsed;
  };
}

export namespace LogoutUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {};
  export type ParsedParameters = {};
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {},
    };

    return parsed;
  };
}

export namespace GetUserByName {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
      },
    };

    // parse username
    const usernameParam = req.params["username"];
    if (usernameParam === undefined) throw new Error("missing username");
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParam);

    return parsed;
  };
}

export namespace UpdateUser {
  export const bodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };
  export type ParsedBody = {
    "application/json":
      | z.infer<(typeof bodySchemas)["application/json"]>
      | undefined;
    "application/x-www-form-urlencoded":
      | z.infer<(typeof bodySchemas)["application/x-www-form-urlencoded"]>
      | undefined;
  };
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {
        "application/json": undefined,
        "application/x-www-form-urlencoded": undefined,
      },
      parameters: {
        username: undefined,
      },
    };

    // parse body
    const contentType = req.headers["content-type"];
    if (contentType && contentType in Object.keys(parsed.body)) {
      const parsedContentType = contentType as ParsedContentType;
      parsed.bodyContentType = parsedContentType;
      parsed.body[parsedContentType] = bodySchemas[parsedContentType]?.parse(
        req.body,
      );
    }

    // parse username
    const usernameParam = req.params["username"];
    if (usernameParam === undefined) throw new Error("missing username");
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParam);

    return parsed;
  };
}

export namespace DeleteUser {
  export const bodySchemas = {};
  export type ParsedBody = {};
  export type ParsedContentType = keyof ParsedBody;
  export const parameterSchemas = {
    username: z.string(),
  };
  export type ParsedParameters = {
    username: z.infer<(typeof parameterSchemas)["username"]> | undefined;
  };
  export type Parsed = {
    bodyContentType: ParsedContentType | undefined;
    body: ParsedBody;
    parameters: ParsedParameters;
  };
  export type Handler = (
    req: Request,
    res: Response,
    parsed: Parsed,
  ) => Promise<void>;

  export const parse = (req: Request): Parsed => {
    const parsed: Parsed = {
      bodyContentType: undefined,
      body: {},
      parameters: {
        username: undefined,
      },
    };

    // parse username
    const usernameParam = req.params["username"];
    if (usernameParam === undefined) throw new Error("missing username");
    parsed.parameters["username"] =
      parameterSchemas["username"]?.parse(usernameParam);

    return parsed;
  };
}

export type PastapiHandlers = {
  updatePet?: UpdatePet.Handler | undefined;
  addPet?: AddPet.Handler | undefined;
  findPetsByStatus?: FindPetsByStatus.Handler | undefined;
  findPetsByTags?: FindPetsByTags.Handler | undefined;
  getPetById?: GetPetById.Handler | undefined;
  updatePetWithForm?: UpdatePetWithForm.Handler | undefined;
  deletePet?: DeletePet.Handler | undefined;
  uploadFile?: UploadFile.Handler | undefined;
  getInventory?: GetInventory.Handler | undefined;
  placeOrder?: PlaceOrder.Handler | undefined;
  getOrderById?: GetOrderById.Handler | undefined;
  deleteOrder?: DeleteOrder.Handler | undefined;
  createUser?: CreateUser.Handler | undefined;
  createUsersWithListInput?: CreateUsersWithListInput.Handler | undefined;
  loginUser?: LoginUser.Handler | undefined;
  logoutUser?: LogoutUser.Handler | undefined;
  getUserByName?: GetUserByName.Handler | undefined;
  updateUser?: UpdateUser.Handler | undefined;
  deleteUser?: DeleteUser.Handler | undefined;
};

export function createRouter(
  handlers: PastapiHandlers,
  logging?: boolean | undefined,
): Router {
  const router = Router();
  router.use((req, res, next) => {
    if (logging) {
      console.log(`${req.method} ${req.path}`);
    }
    next();
  });

  const updatePetRouter = Router();
  updatePetRouter.put("*", async (req: Request, res: Response) => {
    const parsed = UpdatePet.parse(req);
    handlers.updatePet?.call({}, req, res, parsed);
  });
  updatePetRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet", updatePetRouter);

  const addPetRouter = Router();
  addPetRouter.post("*", async (req: Request, res: Response) => {
    const parsed = AddPet.parse(req);
    handlers.addPet?.call({}, req, res, parsed);
  });
  addPetRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet", addPetRouter);

  const findPetsByStatusRouter = Router();
  findPetsByStatusRouter.get("*", async (req: Request, res: Response) => {
    const parsed = FindPetsByStatus.parse(req);
    handlers.findPetsByStatus?.call({}, req, res, parsed);
  });
  findPetsByStatusRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet/findByStatus", findPetsByStatusRouter);

  const findPetsByTagsRouter = Router();
  findPetsByTagsRouter.get("*", async (req: Request, res: Response) => {
    const parsed = FindPetsByTags.parse(req);
    handlers.findPetsByTags?.call({}, req, res, parsed);
  });
  findPetsByTagsRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet/findByTags", findPetsByTagsRouter);

  const getPetByIdRouter = Router();
  getPetByIdRouter.get("*", async (req: Request, res: Response) => {
    const parsed = GetPetById.parse(req);
    handlers.getPetById?.call({}, req, res, parsed);
  });
  getPetByIdRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet/:petId", getPetByIdRouter);

  const updatePetWithFormRouter = Router();
  updatePetWithFormRouter.post("*", async (req: Request, res: Response) => {
    const parsed = UpdatePetWithForm.parse(req);
    handlers.updatePetWithForm?.call({}, req, res, parsed);
  });
  updatePetWithFormRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/pet/:petId", updatePetWithFormRouter);

  const deletePetRouter = Router();
  deletePetRouter.delete("*", async (req: Request, res: Response) => {
    const parsed = DeletePet.parse(req);
    handlers.deletePet?.call({}, req, res, parsed);
  });
  deletePetRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/pet/:petId", deletePetRouter);

  const uploadFileRouter = Router();
  uploadFileRouter.post("*", async (req: Request, res: Response) => {
    const parsed = UploadFile.parse(req);
    handlers.uploadFile?.call({}, req, res, parsed);
  });
  uploadFileRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/pet/:petId/uploadImage", uploadFileRouter);

  const getInventoryRouter = Router();
  getInventoryRouter.get("*", async (req: Request, res: Response) => {
    const parsed = GetInventory.parse(req);
    handlers.getInventory?.call({}, req, res, parsed);
  });
  getInventoryRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/store/inventory", getInventoryRouter);

  const placeOrderRouter = Router();
  placeOrderRouter.post("*", async (req: Request, res: Response) => {
    const parsed = PlaceOrder.parse(req);
    handlers.placeOrder?.call({}, req, res, parsed);
  });
  placeOrderRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/store/order", placeOrderRouter);

  const getOrderByIdRouter = Router();
  getOrderByIdRouter.get("*", async (req: Request, res: Response) => {
    const parsed = GetOrderById.parse(req);
    handlers.getOrderById?.call({}, req, res, parsed);
  });
  getOrderByIdRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/store/order/:orderId", getOrderByIdRouter);

  const deleteOrderRouter = Router();
  deleteOrderRouter.delete("*", async (req: Request, res: Response) => {
    const parsed = DeleteOrder.parse(req);
    handlers.deleteOrder?.call({}, req, res, parsed);
  });
  deleteOrderRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/store/order/:orderId", deleteOrderRouter);

  const createUserRouter = Router();
  createUserRouter.post("*", async (req: Request, res: Response) => {
    const parsed = CreateUser.parse(req);
    handlers.createUser?.call({}, req, res, parsed);
  });
  createUserRouter.use("*", async (req, res, next) => {
    if (res.getHeader("content-type") === "application/json") {
      // TODO validate application/json default response
    } else if (res.getHeader("content-type") === "application/xml") {
      // TODO validate application/xml default response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/user", createUserRouter);

  const createUsersWithListInputRouter = Router();
  createUsersWithListInputRouter.post(
    "*",
    async (req: Request, res: Response) => {
      const parsed = CreateUsersWithListInput.parse(req);
      handlers.createUsersWithListInput?.call({}, req, res, parsed);
    },
  );
  createUsersWithListInputRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/user/createWithList", createUsersWithListInputRouter);

  const loginUserRouter = Router();
  loginUserRouter.get("*", async (req: Request, res: Response) => {
    const parsed = LoginUser.parse(req);
    handlers.loginUser?.call({}, req, res, parsed);
  });
  loginUserRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/user/login", loginUserRouter);

  const logoutUserRouter = Router();
  logoutUserRouter.get("*", async (req: Request, res: Response) => {
    const parsed = LogoutUser.parse(req);
    handlers.logoutUser?.call({}, req, res, parsed);
  });
  logoutUserRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/user/logout", logoutUserRouter);

  const getUserByNameRouter = Router();
  getUserByNameRouter.get("*", async (req: Request, res: Response) => {
    const parsed = GetUserByName.parse(req);
    handlers.getUserByName?.call({}, req, res, parsed);
  });
  getUserByNameRouter.use("*", async (req, res, next) => {
    if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/json"
    ) {
      // TODO validate application/json 200 response
    } else if (
      res.statusCode == 200 &&
      res.getHeader("content-type") === "application/xml"
    ) {
      // TODO validate application/xml 200 response
    } else {
      // response not handled
    }

    next();
  });
  router.use("/user/:username", getUserByNameRouter);

  const updateUserRouter = Router();
  updateUserRouter.put("*", async (req: Request, res: Response) => {
    const parsed = UpdateUser.parse(req);
    handlers.updateUser?.call({}, req, res, parsed);
  });
  updateUserRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/user/:username", updateUserRouter);

  const deleteUserRouter = Router();
  deleteUserRouter.delete("*", async (req: Request, res: Response) => {
    const parsed = DeleteUser.parse(req);
    handlers.deleteUser?.call({}, req, res, parsed);
  });
  deleteUserRouter.use("*", async (req, res, next) => {
    next();
  });
  router.use("/user/:username", deleteUserRouter);

  return router;
}
