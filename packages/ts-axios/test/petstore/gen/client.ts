/*  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
/   ‚ïë üçù  Generated by Pastapi  üçù ‚ïë
/   ‚ïë        Do not modify.        ‚ïë
/   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
/   
*/

import { z } from "zod";
import axios, { AxiosRequestConfig, AxiosInstance, AxiosResponse } from "axios";

export namespace UpdatePet {
  export const requestBodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };

  export type RequestBody =
    | {
        contentType: "application/json";
        body: z.infer<(typeof requestBodySchemas)["application/json"]>;
      }
    | {
        contentType: "application/xml";
        body: z.infer<(typeof requestBodySchemas)["application/xml"]>;
      }
    | {
        contentType: "application/x-www-form-urlencoded";
        body: z.infer<
          (typeof requestBodySchemas)["application/x-www-form-urlencoded"]
        >;
      };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "put",
      url: `/pet`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace AddPet {
  export const requestBodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
  };

  export type RequestBody =
    | {
        contentType: "application/json";
        body: z.infer<(typeof requestBodySchemas)["application/json"]>;
      }
    | {
        contentType: "application/xml";
        body: z.infer<(typeof requestBodySchemas)["application/xml"]>;
      }
    | {
        contentType: "application/x-www-form-urlencoded";
        body: z.infer<
          (typeof requestBodySchemas)["application/x-www-form-urlencoded"]
        >;
      };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace FindPetsByStatus {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.array(
      z.object({
        id: z.number().int().optional(),
        name: z.string(),
        category: z
          .object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          })
          .optional(),
        photoUrls: z.array(z.string()),
        tags: z
          .array(
            z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["available", "pending", "sold"]).optional(),
      }),
    ),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.array(
      z.object({
        id: z.number().int().optional(),
        name: z.string(),
        category: z
          .object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          })
          .optional(),
        photoUrls: z.array(z.string()),
        tags: z
          .array(
            z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["available", "pending", "sold"]).optional(),
      }),
    ),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    status: z
      .enum(["available", "pending", "sold"])
      .default("available")
      .optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      status: z.infer<(typeof requestParamSchemas)["status"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/findByStatus`,
      headers: {},
      params: {
        status: requestParamSchemas["status"].parse(vars.status, {
          path: ["request", "status"],
        }),
      },

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace FindPetsByTags {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.array(
      z.object({
        id: z.number().int().optional(),
        name: z.string(),
        category: z
          .object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          })
          .optional(),
        photoUrls: z.array(z.string()),
        tags: z
          .array(
            z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["available", "pending", "sold"]).optional(),
      }),
    ),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.array(
      z.object({
        id: z.number().int().optional(),
        name: z.string(),
        category: z
          .object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          })
          .optional(),
        photoUrls: z.array(z.string()),
        tags: z
          .array(
            z.object({
              id: z.number().int().optional(),
              name: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["available", "pending", "sold"]).optional(),
      }),
    ),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    tags: z.array(z.string()).optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      tags: z.infer<(typeof requestParamSchemas)["tags"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/findByTags`,
      headers: {},
      params: {
        tags: requestParamSchemas["tags"].parse(vars.tags, {
          path: ["request", "tags"],
        }),
      },

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetPetById {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      name: z.string(),
      category: z
        .object({
          id: z.number().int().optional(),
          name: z.string().optional(),
        })
        .optional(),
      photoUrls: z.array(z.string()),
      tags: z
        .array(
          z.object({
            id: z.number().int().optional(),
            name: z.string().optional(),
          }),
        )
        .optional(),
      status: z.enum(["available", "pending", "sold"]).optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    petId: z.number().int(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      petId: z.infer<(typeof requestParamSchemas)["petId"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/${vars.petId}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace UpdatePetWithForm {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    petId: z.number().int(),
    name: z.string().optional(),
    status: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      petId: z.infer<(typeof requestParamSchemas)["petId"]>;
      name: z.infer<(typeof requestParamSchemas)["name"]>;
      status: z.infer<(typeof requestParamSchemas)["status"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet/${vars.petId}`,
      headers: {},
      params: {
        name: requestParamSchemas["name"].parse(vars.name, {
          path: ["request", "name"],
        }),
        status: requestParamSchemas["status"].parse(vars.status, {
          path: ["request", "status"],
        }),
      },

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}
export namespace DeletePet {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    apiKey: z.string().optional(),
    petId: z.number().int(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      apiKey: z.infer<(typeof requestParamSchemas)["apiKey"]>;
      petId: z.infer<(typeof requestParamSchemas)["petId"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/pet/${vars.petId}`,
      headers: {
        api_key: requestParamSchemas["apiKey"].parse(vars.apiKey, {
          path: ["request", "apiKey"],
        }),
      },
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}
export namespace UploadFile {
  export const requestBodySchemas = {
    "application/octet-stream": z.string(),
  };

  export type RequestBody = {
    contentType: "application/octet-stream";
    body: z.infer<(typeof requestBodySchemas)["application/octet-stream"]>;
  };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      code: z.number().int().optional(),
      type: z.string().optional(),
      message: z.string().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200ApplicationJson];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    petId: z.number().int(),
    additionalMetadata: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      petId: z.infer<(typeof requestParamSchemas)["petId"]>;
      additionalMetadata: z.infer<
        (typeof requestParamSchemas)["additionalMetadata"]
      >;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet/${vars.petId}/uploadImage`,
      headers: {
        "Content-Type": "application/octet-stream",
      },
      params: {
        additionalMetadata: requestParamSchemas["additionalMetadata"].parse(
          vars.additionalMetadata,
          { path: ["request", "additionalMetadata"] },
        ),
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetInventory {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.record(z.number().int()),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200ApplicationJson];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/store/inventory`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace PlaceOrder {
  export const requestBodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
  };

  export type RequestBody =
    | {
        contentType: "application/json";
        body: z.infer<(typeof requestBodySchemas)["application/json"]>;
      }
    | {
        contentType: "application/xml";
        body: z.infer<(typeof requestBodySchemas)["application/xml"]>;
      }
    | {
        contentType: "application/x-www-form-urlencoded";
        body: z.infer<
          (typeof requestBodySchemas)["application/x-www-form-urlencoded"]
        >;
      };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200ApplicationJson];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/store/order`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetOrderById {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      petId: z.number().int().optional(),
      quantity: z.number().int().optional(),
      shipDate: z.string().datetime().optional(),
      status: z.enum(["placed", "approved", "delivered"]).optional(),
      complete: z.boolean().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    orderId: z.number().int(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      orderId: z.infer<(typeof requestParamSchemas)["orderId"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/store/order/${vars.orderId}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace DeleteOrder {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    orderId: z.number().int(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      orderId: z.infer<(typeof requestParamSchemas)["orderId"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/store/order/${vars.orderId}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}
export namespace CreateUser {
  export const requestBodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };

  export type RequestBody =
    | {
        contentType: "application/json";
        body: z.infer<(typeof requestBodySchemas)["application/json"]>;
      }
    | {
        contentType: "application/xml";
        body: z.infer<(typeof requestBodySchemas)["application/xml"]>;
      }
    | {
        contentType: "application/x-www-form-urlencoded";
        body: z.infer<
          (typeof requestBodySchemas)["application/x-www-form-urlencoded"]
        >;
      };

  export const responseSchemadefaultApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemadefaultApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemasdefault = [
    responseSchemadefaultApplicationJson,
    responseSchemadefaultApplicationXml,
  ];

  export const responseSchemas = [
    ...responseSchemasdefault,
    ...responseSchemasdefault,
  ];

  export type ResponseBodydefaultApplicationJson = z.infer<
    (typeof responseSchemadefaultApplicationJson)["bodySchema"]
  >;
  export type ResponseBodydefaultApplicationXml = z.infer<
    (typeof responseSchemadefaultApplicationXml)["bodySchema"]
  >;

  export type ResponseBodydefault =
    | ResponseBodydefaultApplicationJson
    | ResponseBodydefaultApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any default response */
    anydefault: ResponseBodydefault | null;
    /** All default responses with content types included in the OpenAPI spec */
    alldefault: ResponseBodydefault | null;
    /** default response with content-type application/json */
    applicationJsondefault: ResponseBodydefaultApplicationJson | null /** default response with content-type application/xml */;
    applicationXmldefault: ResponseBodydefaultApplicationXml | null;
    /** All default responses with content types not included in the OpenAPI spec */
    otherdefault: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/user`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      anydefault: null,
      alldefault: null,
      applicationJsondefault: null,
      applicationXmldefault: null,
      otherdefault: null,
      other: null,
    };

    if (/^default$/.test(res.status.toString())) {
      safeRes.anydefault = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJsondefault = res.data;
        safeRes.alldefault = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXmldefault = res.data;
        safeRes.alldefault = res.data;
        safeRes.all = res.data;
      } else safeRes.otherdefault = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace CreateUsersWithListInput {
  export const requestBodySchemas = {
    "application/json": z.array(
      z.object({
        id: z.number().int().optional(),
        username: z.string().optional(),
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        email: z.string().optional(),
        password: z.string().optional(),
        phone: z.string().optional(),
        userStatus: z.number().int().optional(),
      }),
    ),
  };

  export type RequestBody = {
    contentType: "application/json";
    body: z.infer<(typeof requestBodySchemas)["application/json"]>;
  };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/user/createWithList`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace LoginUser {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationXml,
    responseSchema200ApplicationJson,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;
  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationXml
    | ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/xml */
    applicationXml200: ResponseBody200ApplicationXml | null /** 200 response with content-type application/json */;
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    username: z.string().optional(),
    password: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      username: z.infer<(typeof requestParamSchemas)["username"]>;
      password: z.infer<(typeof requestParamSchemas)["password"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/login`,
      headers: {},
      params: {
        username: requestParamSchemas["username"].parse(vars.username, {
          path: ["request", "username"],
        }),
        password: requestParamSchemas["password"].parse(vars.password, {
          path: ["request", "password"],
        }),
      },

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationXml200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace LogoutUser {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/logout`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}
export namespace GetUserByName {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchema200ApplicationXml = {
    contentType: "application/xml",
    bodySchema: z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [
    responseSchema200ApplicationJson,
    responseSchema200ApplicationXml,
  ];

  export const responseSchemas = [...responseSchemas200, ...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;
  export type ResponseBody200ApplicationXml = z.infer<
    (typeof responseSchema200ApplicationXml)["bodySchema"]
  >;

  export type ResponseBody200 =
    | ResponseBody200ApplicationJson
    | ResponseBody200ApplicationXml;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: ResponseBody200 | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null /** 200 response with content-type application/xml */;
    applicationXml200: ResponseBody200ApplicationXml | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    username: z.string(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      username: z.infer<(typeof requestParamSchemas)["username"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/${vars.username}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      applicationXml200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else if (res.headers["content-type"] == "application/xml") {
        safeRes.applicationXml200 = res.data;
        safeRes.all200 = res.data;
        safeRes.all = res.data;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace UpdateUser {
  export const requestBodySchemas = {
    "application/json": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/xml": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
    "application/x-www-form-urlencoded": z.object({
      id: z.number().int().optional(),
      username: z.string().optional(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      email: z.string().optional(),
      password: z.string().optional(),
      phone: z.string().optional(),
      userStatus: z.number().int().optional(),
    }),
  };

  export type RequestBody =
    | {
        contentType: "application/json";
        body: z.infer<(typeof requestBodySchemas)["application/json"]>;
      }
    | {
        contentType: "application/xml";
        body: z.infer<(typeof requestBodySchemas)["application/xml"]>;
      }
    | {
        contentType: "application/x-www-form-urlencoded";
        body: z.infer<
          (typeof requestBodySchemas)["application/x-www-form-urlencoded"]
        >;
      };

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    username: z.string(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      username: z.infer<(typeof requestParamSchemas)["username"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "put",
      url: `/user/${vars.username}`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}
export namespace DeleteUser {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchemas = [];

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;

    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    username: z.string(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      username: z.infer<(typeof requestParamSchemas)["username"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/user/${vars.username}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,

      other: null,
    };

    return safeRes;
  };
}

export class Client {
  public axiosInstance: AxiosInstance;
  constructor(axiosInstance?: AxiosInstance) {
    this.axiosInstance = axiosInstance ?? axios.create();
  }

  public async updatePet(
    vars: UpdatePet.Variables,
    config?: AxiosRequestConfig<Pick<UpdatePet.RequestBody, "body">>,
  ) {
    return UpdatePet.request(this.axiosInstance, vars, config);
  }

  public async updatePetSafe(
    vars: UpdatePet.Variables,
    config?: AxiosRequestConfig<Pick<UpdatePet.RequestBody, "body">>,
  ) {
    return UpdatePet.requestSafe(this.axiosInstance, vars, config);
  }

  public async addPet(
    vars: AddPet.Variables,
    config?: AxiosRequestConfig<Pick<AddPet.RequestBody, "body">>,
  ) {
    return AddPet.request(this.axiosInstance, vars, config);
  }

  public async addPetSafe(
    vars: AddPet.Variables,
    config?: AxiosRequestConfig<Pick<AddPet.RequestBody, "body">>,
  ) {
    return AddPet.requestSafe(this.axiosInstance, vars, config);
  }

  public async findPetsByStatus(
    vars: FindPetsByStatus.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return FindPetsByStatus.request(this.axiosInstance, vars, config);
  }

  public async findPetsByStatusSafe(
    vars: FindPetsByStatus.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return FindPetsByStatus.requestSafe(this.axiosInstance, vars, config);
  }

  public async findPetsByTags(
    vars: FindPetsByTags.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return FindPetsByTags.request(this.axiosInstance, vars, config);
  }

  public async findPetsByTagsSafe(
    vars: FindPetsByTags.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return FindPetsByTags.requestSafe(this.axiosInstance, vars, config);
  }

  public async getPetById(
    vars: GetPetById.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetPetById.request(this.axiosInstance, vars, config);
  }

  public async getPetByIdSafe(
    vars: GetPetById.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetPetById.requestSafe(this.axiosInstance, vars, config);
  }

  public async updatePetWithForm(
    vars: UpdatePetWithForm.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return UpdatePetWithForm.request(this.axiosInstance, vars, config);
  }

  public async updatePetWithFormSafe(
    vars: UpdatePetWithForm.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return UpdatePetWithForm.requestSafe(this.axiosInstance, vars, config);
  }

  public async deletePet(
    vars: DeletePet.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeletePet.request(this.axiosInstance, vars, config);
  }

  public async deletePetSafe(
    vars: DeletePet.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeletePet.requestSafe(this.axiosInstance, vars, config);
  }

  public async uploadFile(
    vars: Omit<UploadFile.Variables, "contentType">,
    config?: AxiosRequestConfig<Pick<UploadFile.RequestBody, "body">>,
  ) {
    return UploadFile.request(
      this.axiosInstance,
      { contentType: "application/octet-stream", ...vars },
      config,
    );
  }

  public async uploadFileSafe(
    vars: Omit<UploadFile.Variables, "contentType">,
    config?: AxiosRequestConfig<Pick<UploadFile.RequestBody, "body">>,
  ) {
    return UploadFile.requestSafe(
      this.axiosInstance,
      { contentType: "application/octet-stream", ...vars },
      config,
    );
  }

  public async getInventory(
    vars: GetInventory.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetInventory.request(this.axiosInstance, vars, config);
  }

  public async getInventorySafe(
    vars: GetInventory.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetInventory.requestSafe(this.axiosInstance, vars, config);
  }

  public async placeOrder(
    vars: PlaceOrder.Variables,
    config?: AxiosRequestConfig<Pick<PlaceOrder.RequestBody, "body">>,
  ) {
    return PlaceOrder.request(this.axiosInstance, vars, config);
  }

  public async placeOrderSafe(
    vars: PlaceOrder.Variables,
    config?: AxiosRequestConfig<Pick<PlaceOrder.RequestBody, "body">>,
  ) {
    return PlaceOrder.requestSafe(this.axiosInstance, vars, config);
  }

  public async getOrderById(
    vars: GetOrderById.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetOrderById.request(this.axiosInstance, vars, config);
  }

  public async getOrderByIdSafe(
    vars: GetOrderById.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetOrderById.requestSafe(this.axiosInstance, vars, config);
  }

  public async deleteOrder(
    vars: DeleteOrder.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeleteOrder.request(this.axiosInstance, vars, config);
  }

  public async deleteOrderSafe(
    vars: DeleteOrder.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeleteOrder.requestSafe(this.axiosInstance, vars, config);
  }

  public async createUser(
    vars: CreateUser.Variables,
    config?: AxiosRequestConfig<Pick<CreateUser.RequestBody, "body">>,
  ) {
    return CreateUser.request(this.axiosInstance, vars, config);
  }

  public async createUserSafe(
    vars: CreateUser.Variables,
    config?: AxiosRequestConfig<Pick<CreateUser.RequestBody, "body">>,
  ) {
    return CreateUser.requestSafe(this.axiosInstance, vars, config);
  }

  public async createUsersWithListInput(
    vars: Omit<CreateUsersWithListInput.Variables, "contentType">,
    config?: AxiosRequestConfig<
      Pick<CreateUsersWithListInput.RequestBody, "body">
    >,
  ) {
    return CreateUsersWithListInput.request(
      this.axiosInstance,
      { contentType: "application/json", ...vars },
      config,
    );
  }

  public async createUsersWithListInputSafe(
    vars: Omit<CreateUsersWithListInput.Variables, "contentType">,
    config?: AxiosRequestConfig<
      Pick<CreateUsersWithListInput.RequestBody, "body">
    >,
  ) {
    return CreateUsersWithListInput.requestSafe(
      this.axiosInstance,
      { contentType: "application/json", ...vars },
      config,
    );
  }

  public async loginUser(
    vars: LoginUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return LoginUser.request(this.axiosInstance, vars, config);
  }

  public async loginUserSafe(
    vars: LoginUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return LoginUser.requestSafe(this.axiosInstance, vars, config);
  }

  public async logoutUser(
    vars: LogoutUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return LogoutUser.request(this.axiosInstance, vars, config);
  }

  public async logoutUserSafe(
    vars: LogoutUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return LogoutUser.requestSafe(this.axiosInstance, vars, config);
  }

  public async getUserByName(
    vars: GetUserByName.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUserByName.request(this.axiosInstance, vars, config);
  }

  public async getUserByNameSafe(
    vars: GetUserByName.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUserByName.requestSafe(this.axiosInstance, vars, config);
  }

  public async updateUser(
    vars: UpdateUser.Variables,
    config?: AxiosRequestConfig<Pick<UpdateUser.RequestBody, "body">>,
  ) {
    return UpdateUser.request(this.axiosInstance, vars, config);
  }

  public async updateUserSafe(
    vars: UpdateUser.Variables,
    config?: AxiosRequestConfig<Pick<UpdateUser.RequestBody, "body">>,
  ) {
    return UpdateUser.requestSafe(this.axiosInstance, vars, config);
  }

  public async deleteUser(
    vars: DeleteUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeleteUser.request(this.axiosInstance, vars, config);
  }

  public async deleteUserSafe(
    vars: DeleteUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return DeleteUser.requestSafe(this.axiosInstance, vars, config);
  }
}

type UndefinedProps<T extends object> = {
  [K in keyof T as undefined extends T[K] ? K : never]?: T[K];
};

// Combine with rest of the reuiqred properties
type OptionalUndefined<T extends object> = UndefinedProps<T> &
  Omit<T, keyof UndefinedProps<T>>;
