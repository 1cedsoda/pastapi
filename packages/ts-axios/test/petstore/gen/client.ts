
/*  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
/   ‚ïë üçù  Generated by Pastapi  üçù ‚ïë
/   ‚ïë        Do not modify.        ‚ïë
/   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
/   
*/

import { z } from "zod";
import axios, { AxiosRequestConfig, AxiosInstance, AxiosResponse } from "axios";


export namespace UpdatePet {
    export const requestBodySchemas = {
       "application/json" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),"application/xml" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),"application/x-www-form-urlencoded" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> } | { contentType: "application/xml", body: z.infer<typeof requestBodySchemas["application/xml"]> } | { contentType: "application/x-www-form-urlencoded", body: z.infer<typeof requestBodySchemas["application/x-www-form-urlencoded"]> }

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "put",
      url: `/pet`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace AddPet {
    export const requestBodySchemas = {
       "application/json" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),"application/xml" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),"application/x-www-form-urlencoded" : z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> } | { contentType: "application/xml", body: z.infer<typeof requestBodySchemas["application/xml"]> } | { contentType: "application/x-www-form-urlencoded", body: z.infer<typeof requestBodySchemas["application/x-www-form-urlencoded"]> }

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace FindPetsByStatus {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.array(z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.array(z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       status : z.enum(["available","pending","sold"]).default("available").optional()
    }

    export type Variables = RequestBody & {
      status: z.infer<typeof requestParamSchemas["status"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/findByStatus`,
      headers: {
        
      },
      params: {
        "status": requestParamSchemas["status"].parse(vars.status, { path: ["request", "status"] })
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace FindPetsByTags {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.array(z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.array(z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()})),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       tags : z.array(z.string()).optional()
    }

    export type Variables = RequestBody & {
      tags: z.infer<typeof requestParamSchemas["tags"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/findByTags`,
      headers: {
        
      },
      params: {
        "tags": requestParamSchemas["tags"].parse(vars.tags, { path: ["request", "tags"] })
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace GetPetById {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"name":z.string(),"category":z.object({"id":z.number().int().optional(),"name":z.string().optional()}).optional(),"photoUrls":z.array(z.string()),"tags":z.array(z.object({"id":z.number().int().optional(),"name":z.string().optional()})).optional(),"status":z.enum(["available","pending","sold"]).optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       petId : z.number().int()
    }

    export type Variables = RequestBody & {
      petId: z.infer<typeof requestParamSchemas["petId"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/pet/${vars.petId}`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace UpdatePetWithForm {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       petId : z.number().int(),name : z.string().optional(),status : z.string().optional()
    }

    export type Variables = RequestBody & {
      petId: z.infer<typeof requestParamSchemas["petId"]>,name: z.infer<typeof requestParamSchemas["name"]>,status: z.infer<typeof requestParamSchemas["status"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet/${vars.petId}`,
      headers: {
        
      },
      params: {
        "name": requestParamSchemas["name"].parse(vars.name, { path: ["request", "name"] }),"status": requestParamSchemas["status"].parse(vars.status, { path: ["request", "status"] })
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace DeletePet {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       apiKey : z.string().optional(),petId : z.number().int()
    }

    export type Variables = RequestBody & {
      apiKey: z.infer<typeof requestParamSchemas["apiKey"]>,petId: z.infer<typeof requestParamSchemas["petId"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/pet/${vars.petId}`,
      headers: {
        "api_key": requestParamSchemas["apiKey"].parse(vars.apiKey, { path: ["request", "apiKey"] })
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace UploadFile {
    export const requestBodySchemas = {
       "application/octet-stream" : z.string()
     }
    export type RequestBody =
      { contentType: "application/octet-stream", body: z.infer<typeof requestBodySchemas["application/octet-stream"]> }

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"code":z.number().int().optional(),"type":z.string().optional(),"message":z.string().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       petId : z.number().int(),additionalMetadata : z.string().optional()
    }

    export type Variables = RequestBody & {
      petId: z.infer<typeof requestParamSchemas["petId"]>,additionalMetadata: z.infer<typeof requestParamSchemas["additionalMetadata"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/pet/${vars.petId}/uploadImage`,
      headers: {
        "Content-Type": "application/octet-stream"
      },
      params: {
        "additionalMetadata": requestParamSchemas["additionalMetadata"].parse(vars.additionalMetadata, { path: ["request", "additionalMetadata"] })
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace GetInventory {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.record(z.number().int()),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/store/inventory`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace PlaceOrder {
    export const requestBodySchemas = {
       "application/json" : z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()}),"application/xml" : z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()}),"application/x-www-form-urlencoded" : z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()})
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> } | { contentType: "application/xml", body: z.infer<typeof requestBodySchemas["application/xml"]> } | { contentType: "application/x-www-form-urlencoded", body: z.infer<typeof requestBodySchemas["application/x-www-form-urlencoded"]> }

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/store/order`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace GetOrderById {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"petId":z.number().int().optional(),"quantity":z.number().int().optional(),"shipDate":z.string().datetime().optional(),"status":z.enum(["placed","approved","delivered"]).optional(),"complete":z.boolean().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       orderId : z.number().int()
    }

    export type Variables = RequestBody & {
      orderId: z.infer<typeof requestParamSchemas["orderId"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/store/order/${vars.orderId}`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace DeleteOrder {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       orderId : z.number().int()
    }

    export type Variables = RequestBody & {
      orderId: z.infer<typeof requestParamSchemas["orderId"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/store/order/${vars.orderId}`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace CreateUser {
    export const requestBodySchemas = {
       "application/json" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),"application/xml" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),"application/x-www-form-urlencoded" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()})
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> } | { contentType: "application/xml", body: z.infer<typeof requestBodySchemas["application/xml"]> } | { contentType: "application/x-www-form-urlencoded", body: z.infer<typeof requestBodySchemas["application/x-www-form-urlencoded"]> }

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      {
          statusCode: "default",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        },{
          statusCode: "default",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/user`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace CreateUsersWithListInput {
    export const requestBodySchemas = {
       "application/json" : z.array(z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}))
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> }

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/user/createWithList`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace LoginUser {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.string(),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.string(),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       username : z.string().optional(),password : z.string().optional()
    }

    export type Variables = RequestBody & {
      username: z.infer<typeof requestParamSchemas["username"]>,password: z.infer<typeof requestParamSchemas["password"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/login`,
      headers: {
        
      },
      params: {
        "username": requestParamSchemas["username"].parse(vars.username, { path: ["request", "username"] }),"password": requestParamSchemas["password"].parse(vars.password, { path: ["request", "password"] })
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace LogoutUser {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       
    }

    export type Variables = RequestBody & {
      
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/logout`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace GetUserByName {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      {
          statusCode: "200",
          contentType: "application/json",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        },{
          statusCode: "200",
          contentType: "application/xml",
          bodySchema: z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),
          headerSchema: z.never()
        }
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       username : z.string()
    }

    export type Variables = RequestBody & {
      username: z.infer<typeof requestParamSchemas["username"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/${vars.username}`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace UpdateUser {
    export const requestBodySchemas = {
       "application/json" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),"application/xml" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()}),"application/x-www-form-urlencoded" : z.object({"id":z.number().int().optional(),"username":z.string().optional(),"firstName":z.string().optional(),"lastName":z.string().optional(),"email":z.string().optional(),"password":z.string().optional(),"phone":z.string().optional(),"userStatus":z.number().int().optional()})
     }
    export type RequestBody =
      { contentType: "application/json", body: z.infer<typeof requestBodySchemas["application/json"]> } | { contentType: "application/xml", body: z.infer<typeof requestBodySchemas["application/xml"]> } | { contentType: "application/x-www-form-urlencoded", body: z.infer<typeof requestBodySchemas["application/x-www-form-urlencoded"]> }

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       username : z.string()
    }

    export type Variables = RequestBody & {
      username: z.infer<typeof requestParamSchemas["username"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "put",
      url: `/user/${vars.username}`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        
      },
      data: requestBodySchemas[vars.contentType].parse(vars.body, { path: ["request", "body"] }),
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<Pick<RequestBody, "body">>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  
export namespace DeleteUser {
    export const requestBodySchemas = {
       
     }
    export type RequestBody =
      {}

    export const responseSchemasOk = [
      
    ]

    export const responseSchemasError = [
      
    ]

    export const responseSchemas = [
      ...responseSchemasOk,
      ...responseSchemasError
    ]
  
    export type ResponseBodyOk = z.infer<(typeof responseSchemasOk[number]["bodySchema"])>
    export type ResponseBodyError = z.infer<(typeof responseSchemasError[number]["bodySchema"])>
    export type ResponseBody = z.infer<(typeof responseSchemas[number]["bodySchema"])>

    export const requestParamSchemas = {
       username : z.string()
    }

    export type Variables = RequestBody & {
      username: z.infer<typeof requestParamSchemas["username"]>
    }

    export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => axios.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "delete",
      url: `/user/${vars.username}`,
      headers: {
        
      },
      params: {
        
      },
      
      ...config
    })

    export const requestSafe = async <REQ_B = RequestBody, RES_B_OK = ResponseBodyOk, RES_B_ERROR = ResponseBodyError>(axios: AxiosInstance, vars: Variables, config?: AxiosRequestConfig<undefined>) => {
      const res = await request<REQ_B, RES_B_OK & RES_B_ERROR>(axios, vars, {
        ...config,
        validateStatus: () => true
      })
      return res.status >= 200 && res.status < 300 ? {
        ok: res as unknown as AxiosResponse<RES_B_OK, REQ_B>,
        error: null,
        any: res as unknown as AxiosResponse<RES_B_OK, REQ_B>
      } : {
        ok: null,
        error: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>,
        any: res as unknown as AxiosResponse<RES_B_ERROR, REQ_B>
      }
    }
  }
  

export class Client {
  public axiosInstance: AxiosInstance
  constructor (
    axiosInstance?: AxiosInstance,
  ) {
    this.axiosInstance = axiosInstance ?? axios.create()
  }

  
  public async updatePet(variables: UpdatePet.Variables, config?: AxiosRequestConfig<Pick<UpdatePet.RequestBody, "body">>) {
    return UpdatePet.request(this.axiosInstance, variables, config)
    }
  

  public async updatePetSafe(variables: UpdatePet.Variables, config?: AxiosRequestConfig<Pick<UpdatePet.RequestBody, "body">>) {
    return UpdatePet.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async addPet(variables: AddPet.Variables, config?: AxiosRequestConfig<Pick<AddPet.RequestBody, "body">>) {
    return AddPet.request(this.axiosInstance, variables, config)
    }
  

  public async addPetSafe(variables: AddPet.Variables, config?: AxiosRequestConfig<Pick<AddPet.RequestBody, "body">>) {
    return AddPet.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async findPetsByStatus(variables: FindPetsByStatus.Variables, config?: AxiosRequestConfig<undefined>) {
    return FindPetsByStatus.request(this.axiosInstance, variables, config)
    }
  

  public async findPetsByStatusSafe(variables: FindPetsByStatus.Variables, config?: AxiosRequestConfig<undefined>) {
    return FindPetsByStatus.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async findPetsByTags(variables: FindPetsByTags.Variables, config?: AxiosRequestConfig<undefined>) {
    return FindPetsByTags.request(this.axiosInstance, variables, config)
    }
  

  public async findPetsByTagsSafe(variables: FindPetsByTags.Variables, config?: AxiosRequestConfig<undefined>) {
    return FindPetsByTags.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async getPetById(variables: GetPetById.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetPetById.request(this.axiosInstance, variables, config)
    }
  

  public async getPetByIdSafe(variables: GetPetById.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetPetById.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async updatePetWithForm(variables: UpdatePetWithForm.Variables, config?: AxiosRequestConfig<undefined>) {
    return UpdatePetWithForm.request(this.axiosInstance, variables, config)
    }
  

  public async updatePetWithFormSafe(variables: UpdatePetWithForm.Variables, config?: AxiosRequestConfig<undefined>) {
    return UpdatePetWithForm.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async deletePet(variables: DeletePet.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeletePet.request(this.axiosInstance, variables, config)
    }
  

  public async deletePetSafe(variables: DeletePet.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeletePet.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async uploadFile(variables: Omit<UploadFile.Variables, "contentType">, config?: AxiosRequestConfig<Pick<UploadFile.RequestBody, "body">>) {
    return UploadFile.request(this.axiosInstance, {"contentType": "application/octet-stream", ...variables}, config)
    }
  

  public async uploadFileSafe(variables: Omit<UploadFile.Variables, "contentType">, config?: AxiosRequestConfig<Pick<UploadFile.RequestBody, "body">>) {
    return UploadFile.requestSafe(this.axiosInstance, {"contentType": "application/octet-stream", ...variables}, config)
    }
  

  public async getInventory(variables: GetInventory.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetInventory.request(this.axiosInstance, variables, config)
    }
  

  public async getInventorySafe(variables: GetInventory.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetInventory.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async placeOrder(variables: PlaceOrder.Variables, config?: AxiosRequestConfig<Pick<PlaceOrder.RequestBody, "body">>) {
    return PlaceOrder.request(this.axiosInstance, variables, config)
    }
  

  public async placeOrderSafe(variables: PlaceOrder.Variables, config?: AxiosRequestConfig<Pick<PlaceOrder.RequestBody, "body">>) {
    return PlaceOrder.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async getOrderById(variables: GetOrderById.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetOrderById.request(this.axiosInstance, variables, config)
    }
  

  public async getOrderByIdSafe(variables: GetOrderById.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetOrderById.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async deleteOrder(variables: DeleteOrder.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeleteOrder.request(this.axiosInstance, variables, config)
    }
  

  public async deleteOrderSafe(variables: DeleteOrder.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeleteOrder.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async createUser(variables: CreateUser.Variables, config?: AxiosRequestConfig<Pick<CreateUser.RequestBody, "body">>) {
    return CreateUser.request(this.axiosInstance, variables, config)
    }
  

  public async createUserSafe(variables: CreateUser.Variables, config?: AxiosRequestConfig<Pick<CreateUser.RequestBody, "body">>) {
    return CreateUser.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async createUsersWithListInput(variables: Omit<CreateUsersWithListInput.Variables, "contentType">, config?: AxiosRequestConfig<Pick<CreateUsersWithListInput.RequestBody, "body">>) {
    return CreateUsersWithListInput.request(this.axiosInstance, {"contentType": "application/json", ...variables}, config)
    }
  

  public async createUsersWithListInputSafe(variables: Omit<CreateUsersWithListInput.Variables, "contentType">, config?: AxiosRequestConfig<Pick<CreateUsersWithListInput.RequestBody, "body">>) {
    return CreateUsersWithListInput.requestSafe(this.axiosInstance, {"contentType": "application/json", ...variables}, config)
    }
  

  public async loginUser(variables: LoginUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return LoginUser.request(this.axiosInstance, variables, config)
    }
  

  public async loginUserSafe(variables: LoginUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return LoginUser.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async logoutUser(variables: LogoutUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return LogoutUser.request(this.axiosInstance, variables, config)
    }
  

  public async logoutUserSafe(variables: LogoutUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return LogoutUser.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async getUserByName(variables: GetUserByName.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetUserByName.request(this.axiosInstance, variables, config)
    }
  

  public async getUserByNameSafe(variables: GetUserByName.Variables, config?: AxiosRequestConfig<undefined>) {
    return GetUserByName.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async updateUser(variables: UpdateUser.Variables, config?: AxiosRequestConfig<Pick<UpdateUser.RequestBody, "body">>) {
    return UpdateUser.request(this.axiosInstance, variables, config)
    }
  

  public async updateUserSafe(variables: UpdateUser.Variables, config?: AxiosRequestConfig<Pick<UpdateUser.RequestBody, "body">>) {
    return UpdateUser.requestSafe(this.axiosInstance, variables, config)
    }
  

  public async deleteUser(variables: DeleteUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeleteUser.request(this.axiosInstance, variables, config)
    }
  

  public async deleteUserSafe(variables: DeleteUser.Variables, config?: AxiosRequestConfig<undefined>) {
    return DeleteUser.requestSafe(this.axiosInstance, variables, config)
    }
  
}

