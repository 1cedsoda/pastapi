/*  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
/   ‚ïë üçù  Generated by Pastapi  üçù ‚ïë
/   ‚ïë        Do not modify.        ‚ïë
/   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
/   
*/

import { z } from "zod";
import axios, { AxiosRequestConfig, AxiosInstance, AxiosResponse } from "axios";

export namespace GetUser {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({ id: z.number().int(), name: z.string() }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200ApplicationJson];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: any | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data as ResponseBody200ApplicationJson;
        safeRes.all200 = res.data as ResponseBody200;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace PostUser {
  export const requestBodySchemas = {
    "application/json": z.object({ id: z.number().int(), name: z.string() }),
  };

  export type RequestBody = {
    contentType: "application/json";
    body: z.infer<(typeof requestBodySchemas)["application/json"]>;
  };

  export const responseSchema200TextPlain = {
    contentType: "text/plain",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200TextPlain];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200TextPlain = z.infer<
    (typeof responseSchema200TextPlain)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200TextPlain;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: any | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type text/plain */
    textPlain200: ResponseBody200TextPlain | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<Pick<RequestBody, "body">>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "post",
      url: `/user`,
      headers: {
        "Content-Type": "application/json",
      },
      params: {},
      data: requestBodySchemas[vars.contentType].parse(vars.body, {
        path: ["request", "body"],
      }),
      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<Pick<RequestBody, "body">>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      textPlain200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "text/plain") {
        safeRes.textPlain200 = res.data as ResponseBody200TextPlain;
        safeRes.all200 = res.data as ResponseBody200;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetUserId {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200ApplicationJson = {
    contentType: "application/json",
    bodySchema: z.object({ id: z.number().int(), name: z.string() }),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200ApplicationJson];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200ApplicationJson = z.infer<
    (typeof responseSchema200ApplicationJson)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200ApplicationJson;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: any | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type application/json */
    applicationJson200: ResponseBody200ApplicationJson | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    id: z.number().int(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      id: z.infer<(typeof requestParamSchemas)["id"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/user/${vars.id}`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      applicationJson200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "application/json") {
        safeRes.applicationJson200 = res.data as ResponseBody200ApplicationJson;
        safeRes.all200 = res.data as ResponseBody200;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetCookie {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema20XTextPlain = {
    contentType: "text/plain",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas20X = [responseSchema20XTextPlain];

  export const responseSchemas = [...responseSchemas20X];

  export type ResponseBody20XTextPlain = z.infer<
    (typeof responseSchema20XTextPlain)["bodySchema"]
  >;

  export type ResponseBody20X = ResponseBody20XTextPlain;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 20X response */
    any20X: any | null;
    /** All 20X responses with content types included in the OpenAPI spec */
    all20X: ResponseBody20X | null;
    /** 20X response with content-type text/plain */
    textPlain20X: ResponseBody20XTextPlain | null;
    /** All 20X responses with content types not included in the OpenAPI spec */
    other20X: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    myRequiredCookie: z.number(),
    myOptionalCookie: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      myRequiredCookie: z.infer<
        (typeof requestParamSchemas)["myRequiredCookie"]
      >;
      myOptionalCookie: z.infer<
        (typeof requestParamSchemas)["myOptionalCookie"]
      >;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/cookie`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any20X: null,
      all20X: null,
      textPlain20X: null,
      other20X: null,
      other: null,
    };

    if (/^20\d$/.test(res.status.toString())) {
      safeRes.any20X = res.data;
      if (res.headers["content-type"] == "text/plain") {
        safeRes.textPlain20X = res.data as ResponseBody20XTextPlain;
        safeRes.all20X = res.data as ResponseBody20X;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other20X = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetHeader {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200TextPlain = {
    contentType: "text/plain",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200TextPlain];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200TextPlain = z.infer<
    (typeof responseSchema200TextPlain)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200TextPlain;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: any | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type text/plain */
    textPlain200: ResponseBody200TextPlain | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    xMyRequiredHeader: z.number(),
    xMyOptionalHeader: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      xMyRequiredHeader: z.infer<
        (typeof requestParamSchemas)["xMyRequiredHeader"]
      >;
      xMyOptionalHeader: z.infer<
        (typeof requestParamSchemas)["xMyOptionalHeader"]
      >;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/header`,
      headers: {
        "X-My-Required-Header": requestParamSchemas["xMyRequiredHeader"].parse(
          vars.xMyRequiredHeader,
          { path: ["request", "xMyRequiredHeader"] },
        ),
        "X-My-Optional-Header": requestParamSchemas["xMyOptionalHeader"].parse(
          vars.xMyOptionalHeader,
          { path: ["request", "xMyOptionalHeader"] },
        ),
      },
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      textPlain200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "text/plain") {
        safeRes.textPlain200 = res.data as ResponseBody200TextPlain;
        safeRes.all200 = res.data as ResponseBody200;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetQuery {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema200TextPlain = {
    contentType: "text/plain",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas200 = [responseSchema200TextPlain];

  export const responseSchemas = [...responseSchemas200];

  export type ResponseBody200TextPlain = z.infer<
    (typeof responseSchema200TextPlain)["bodySchema"]
  >;

  export type ResponseBody200 = ResponseBody200TextPlain;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 200 response */
    any200: any | null;
    /** All 200 responses with content types included in the OpenAPI spec */
    all200: ResponseBody200 | null;
    /** 200 response with content-type text/plain */
    textPlain200: ResponseBody200TextPlain | null;
    /** All 200 responses with content types not included in the OpenAPI spec */
    other200: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {
    a: z.number(),
    b: z.string().optional(),
  };

  export type Variables = RequestBody &
    OptionalUndefined<{
      a: z.infer<(typeof requestParamSchemas)["a"]>;
      b: z.infer<(typeof requestParamSchemas)["b"]>;
    }>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/query`,
      headers: {},
      params: {
        a: requestParamSchemas["a"].parse(vars.a, { path: ["request", "a"] }),
        b: requestParamSchemas["b"].parse(vars.b, { path: ["request", "b"] }),
      },

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any200: null,
      all200: null,
      textPlain200: null,
      other200: null,
      other: null,
    };

    if (/^200$/.test(res.status.toString())) {
      safeRes.any200 = res.data;
      if (res.headers["content-type"] == "text/plain") {
        safeRes.textPlain200 = res.data as ResponseBody200TextPlain;
        safeRes.all200 = res.data as ResponseBody200;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other200 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}
export namespace GetError {
  export const requestBodySchemas = {};

  export type RequestBody = {};

  export const responseSchema500TextPlain = {
    contentType: "text/plain",
    bodySchema: z.string(),
    headerSchema: z.never(),
  };

  export const responseSchemas500 = [responseSchema500TextPlain];

  export const responseSchemas = [...responseSchemas500];

  export type ResponseBody500TextPlain = z.infer<
    (typeof responseSchema500TextPlain)["bodySchema"]
  >;

  export type ResponseBody500 = ResponseBody500TextPlain;

  export type ResponseBody = z.infer<
    (typeof responseSchemas)[number]["bodySchema"]
  >;

  export type ResponseBodySafe = {
    /** All responses */
    any: any;
    /** All responses with status code and content-type included in the OpenAPI spec */
    all: ResponseBody | null;
    /** Any 500 response */
    any500: any | null;
    /** All 500 responses with content types included in the OpenAPI spec */
    all500: ResponseBody500 | null;
    /** 500 response with content-type text/plain */
    textPlain500: ResponseBody500TextPlain | null;
    /** All 500 responses with content types not included in the OpenAPI spec */
    other500: any | null;
    /** If status isn't included in the OpenAPI spec */
    other: any | null;
  };

  export const requestParamSchemas = {};

  export type Variables = RequestBody & OptionalUndefined<{}>;

  export const request = async <REQ_B = RequestBody, RES_B = ResponseBody>(
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosRequestConfig<undefined>,
  ) =>
    axiosInstance.request<REQ_B, AxiosResponse<RES_B, REQ_B>>({
      method: "get",
      url: `/error`,
      headers: {},
      params: {},

      ...config,
    });

  export type AxiosConfig = AxiosRequestConfig<undefined>;

  export const requestSafe = async (
    axiosInstance: AxiosInstance,
    vars: Variables,
    config?: AxiosConfig,
  ): Promise<ResponseBodySafe> => {
    const res = await request(axiosInstance, vars, {
      ...config,
      validateStatus: () => true,
    });
    let safeRes: ResponseBodySafe = {
      any: res.data,
      all: null,
      any500: null,
      all500: null,
      textPlain500: null,
      other500: null,
      other: null,
    };

    if (/^500$/.test(res.status.toString())) {
      safeRes.any500 = res.data;
      if (res.headers["content-type"] == "text/plain") {
        safeRes.textPlain500 = res.data as ResponseBody500TextPlain;
        safeRes.all500 = res.data as ResponseBody500;
        safeRes.all = res.data as ResponseBody;
      } else safeRes.other500 = res.data;
    } else safeRes.other = res.data;
    return safeRes;
  };
}

export class Client {
  public axiosInstance: AxiosInstance;
  constructor(axiosInstance?: AxiosInstance) {
    this.axiosInstance = axiosInstance ?? axios.create();
  }

  public async getUser(
    vars: GetUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUser.request(this.axiosInstance, vars, config);
  }

  public async getUserSafe(
    vars: GetUser.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUser.requestSafe(this.axiosInstance, vars, config);
  }

  public async postUser(
    vars: Omit<PostUser.Variables, "contentType">,
    config?: AxiosRequestConfig<Pick<PostUser.RequestBody, "body">>,
  ) {
    return PostUser.request(
      this.axiosInstance,
      { contentType: "application/json", ...vars },
      config,
    );
  }

  public async postUserSafe(
    vars: Omit<PostUser.Variables, "contentType">,
    config?: AxiosRequestConfig<Pick<PostUser.RequestBody, "body">>,
  ) {
    return PostUser.requestSafe(
      this.axiosInstance,
      { contentType: "application/json", ...vars },
      config,
    );
  }

  public async getUserId(
    vars: GetUserId.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUserId.request(this.axiosInstance, vars, config);
  }

  public async getUserIdSafe(
    vars: GetUserId.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetUserId.requestSafe(this.axiosInstance, vars, config);
  }

  public async getCookie(
    vars: GetCookie.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetCookie.request(this.axiosInstance, vars, config);
  }

  public async getCookieSafe(
    vars: GetCookie.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetCookie.requestSafe(this.axiosInstance, vars, config);
  }

  public async getHeader(
    vars: GetHeader.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetHeader.request(this.axiosInstance, vars, config);
  }

  public async getHeaderSafe(
    vars: GetHeader.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetHeader.requestSafe(this.axiosInstance, vars, config);
  }

  public async getQuery(
    vars: GetQuery.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetQuery.request(this.axiosInstance, vars, config);
  }

  public async getQuerySafe(
    vars: GetQuery.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetQuery.requestSafe(this.axiosInstance, vars, config);
  }

  public async getError(
    vars: GetError.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetError.request(this.axiosInstance, vars, config);
  }

  public async getErrorSafe(
    vars: GetError.Variables,
    config?: AxiosRequestConfig<undefined>,
  ) {
    return GetError.requestSafe(this.axiosInstance, vars, config);
  }
}

type UndefinedProps<T extends object> = {
  [K in keyof T as undefined extends T[K] ? K : never]?: T[K];
};

// Combine with rest of the reuiqred properties
type OptionalUndefined<T extends object> = UndefinedProps<T> &
  Omit<T, keyof UndefinedProps<T>>;
